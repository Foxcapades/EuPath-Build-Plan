= Build System
:icons: font
ifdef::env-github[]
:warning-caption: âš 
endif::[]
:toc: left
:toclevels: 3
Elizabeth Harper <epharper@upenn.edu>

// External URLS
:condSubstBlog: https://medium.com/codequest/Gradle-multi-project-build-substituting-jar-dependencies-with-local-projects-4a5323f8680b
:condSubstDocs: https://docs.Gradle.org/current/userguide/customizing_dependency_resolution_behavior.html
:docSrc: https://github.com/Foxcapades/EuPath-Build-Plan
:docPage: https://foxcapades.github.io/EuPath-Build-Plan/readme.html
:javaPlatDocs: https://docs.gradle.org/current/userguide/java_platform_plugin.html
:cpanGitUse: https://metacpan.org/pod/distribution/App-cpanminus/bin/cpanm



Document Render: {docPage} +
Document Source: {docSrc}

== Goals

1. Modernize our build process
2. Break apart the monolith build
3. Simplify/Unify our build scripts
4. Separate build from deployment
5. Separate build from version control


== Increments


=== Part 1: Maven to Gradle

Exchange the maven pom files for Gradle builds.  Parts of
the Ant build that call to maven will now call to Gradle.

Gradle projects will declare their project dependencies and
the build should function similarly to the previous build
system.

The base-pom file will be converted to a Gradle <<javaPlat,
`java-platform`>> Bill of Materials.

Boilerplate details, such as developer information or custom
artifact repositories will be extracted to a Gradle plugin
which can be published to a Maven repository.

This conversion is almost 1 to 1 and wil be tedious, but
should not be not difficult.  This particular change should
only affect users in that the log output will be different.

At this point in time the Gradle distribution will follow
the standard practice of including a base version in the
source repository.

WARNING: TODO: get a list of all scripts that call Maven
  directly

==== Impact on Servers

None as Gradle will be included with the source code.

For developer convenience (potentially faster builds) it may
be nice to have Gradle installed on the development servers,
but this is not required.

==== Impact on Jenkins

None at this point, the Jenkins `rebuilder` script will call
Ant as normal.

==== Impact on Developers

Different looking log output during build.

Potentially faster project build times.


=== Part 2: Ant to Gradle

Convert the build XML declarations into Gradle actions.

At this point, custom scripts will be left alone, calls to
them will be maintained, and converted to calls from Gradle.

Most Ant actions or behaviors are available easily in Gradle
or can be easily recreated as a function in Gradle.  Any Ant
functions we rely on which have no built-in mirror in Gradle
will be made into a plugin which will be published to our
internal Maven repository to be made available to all
projects.

WARNING: TODO: get a list of all scripts that call Ant
  directly.


==== Impact on Servers

The `rebuilder` script will be updated to call Gradle rather
than Ant.


==== Impact on Jenkins

The Jenkins `rebuilder` script will be updated to call
Gradle rather than Ant.

==== Impact on Developers

Any Ant calls will now be made through Gradle.


=== Part 3: Scripts to Gradle

Convert the custom wrapper and helper scripts into Gradle
actions.

This will mean custom (Java) code will need to be written.
This code will be created as a Gradle plugin and published
to our internal Maven server so as to be made available to
all project builds.

WARNING: TODO: Find out what scripts exist on the servers
  that call Ant, Maven, or other build scripts.


=== Part 4: Split the monolith

Take each project's Gradle build and convert its dependency
on sibling projects into artifact dependencies with
<<#condSubst,Conditional Substitution>>.


=== Part 5: Deployments




== Issues / Concerns


=== Bundling of non-java project code


With Gradle's customizable nature, additional compile tasks
can be added for non-Java source code.

In CI additional steps can be performed to publish those
components as bundles or packages as per the standard
practices for the specific language.

In early phases of the build update, non-Java dependencies
will be treated as they are in the current build process.

When we migrate towards a separate build/deploy strategy
we will need to have a system in place to host, version, and
update these dependencies.

==== Possible approaches by language

===== Perl

With Perl we have a couple of options available to us.  We
can use a private CPAN repository, or alternatively, we can
split the Perl code into separate git repositories and
depend on it {cpanGitUse}[via git itself].

====== Versioning

Depending on the package hosting approach above we may use
different strategies, using git we can use git tags to
maintain releases or different versions.  Using a private
CPAN repository, we would need to come up with a concrete
versioning strategy.

===== JavaScript/TypeScript

This is already handled for us via NPM or Yarn.  Similarly
to Perl, we may desire to host our JavaScript & TypeScript
code in a private NPM repository, or split that code out and
just use git.

==== R

WARNING: TODO

==== C

WARNING: TODO

==== Python

WARNING: TODO

==== Others?

WARNING: TODO

=== Artifact Versioning

WARNING: Everything about this needs to be discussed.  The
  below sections outline a rough idea that may work for our
  team.

==== Releases


For releases, artifacts will be built using the version
format `<siteRelease>.<artifactBuild>` or, for example
`46.0`.  The java platform project will be updated to
reflect the concrete versions of the artifacts that will be
used for a site release.

The `<artifactBuild>` will be the number of builds of the
release artifact for a site version, so as live patches are
added, this number will increment.

.Example Release History
[source]
----
WDK:
  48.0 - Site Release
  48.1 - Memory leak fix
  49.0 - Site Release
  49.1 - Corrected typo
  49.2 - Fix for user-comment search
----


==== Development

While in development artifacts will be versioned using the
format `<nextRelease>.SNAPSHOT-<artifactBuildNumber>`.

The `<artifactBuildNumber>` (and potentially `<nextRelease>`)
params will be managed by CI to avoid conflicts.

The development <<javaPlat,Java Platform>> will be given a
wildcard version identifier that simply specifies that
builds should use the latest artifact.

.Example Version History
[source]
----
WDK:
  46.SNAPSHOT-105: Added public user datasets to user dataset list
  46.SNAPSHOT-106: Corrected issue with deleted public user datasets
--- Site Build 47 released---
  47.SNAPSHOT-1: Added user id field to service endpoint result
  47.SNAPSHOT-2: Reworked question service
----


=== Multi-project development workflow

Initially the projects will declare each other as local
dependencies which will mean that components will be rebuilt
as needed in a manner similar to the previous builds.

Eventually dependencies will be handled with conditional
substitutions, a built in Gradle feature, which will use a
local project when available instead of the Maven repository
version of that dependency.


== New Tools


=== Gradle

Build / dependency management tool.  Can be used as a
replacement for Maven, Ant, and many of our custom wrapper
scripts and tools.

Gradle is a JVM language oriented build manager, but can be
and is used for non-jvm build and dependency management.

==== Features

Dependency Management::
  * Primarily uses Maven repositories for retrieving
    dependencies, and follows traditional Maven versioning
    behavior
  * can be extended through many plugins to pull from
    different source types, such as a git repo, npm, etc..
  
Artifact Builds::
  * Comes with a default suite of build functionalities
    that cover most common cases
  * can be easily extended inline, with custom, project
    specific code, or with easily constructed plugins
  
Artifact Publishing::
  * Can be used to push new builds to an artifact
    repository, though traditionally the CI would be the
    only one to perform this specific task

Extensibility::
  * Gradle builds can be customized or extended using
    project-local scripts or plugins using most JVM
    languages.  Extending a build or providing extra
    utilities can be easily done with just a single java
    file if desired.

Faster Builds::
  * Gradle will attempt to build projects or components in
    parallel when applicable.
  * Gradle is also clever about what actually needs to be
    rebuilt, with a `make` like behavior, only classes that
    actually changed will be rebuilt.


=== Artifact Repositories

For us to move forward and make use of modern/standard
tooling practices surrounding builds/deployments/etc... we
will be migrating away from our 'build everything' approach
and only building specific components on change.
Sites can then be deployed without the need to perform build
tasks.

Since our project does contain some private components that
are part of a running site, we will need one or more private
artifact repositories.


==== Java/Maven

This will be required for our datasets/presenters projects
at minimum, however since our libraries aren't really
intended for mass use, we could publish all our artifacts
to this internal repository.


==== JavaScript/NPM

Not required, but may be helpful down the road, front end
team can discuss and decide what needs, if any, this could
fill.

Additionally, since our UI code is not private, using the
public NPM is an option that would not necessarily require
ops involvement.


==== Perl/CPAN/Carton


WARNING: TODO, investigate this further...


== Questions

- Conifer???

- Versioning of libs?

- Factoring builds?

- Division of deployments?

- Triggers for builds?  (build cascade when a dependency)
  Does conditional substitution trigger child project builds?


== Definitions

[[condSubst]]Conditional Substitution::
A Gradle feature that enables the substitution of one
dependency with another if some condition is met.
+
In our case this would likely mean using a sibling project
instead of an artifact if that project exists in your
workspace.
+
See {condSubstBlog}[this blog post], or {condSubstDocs}[the
Gradle docs] for a more detailed explanation.

[[javaPlat]]Java Platform::
The Gradle method of creating a Bill of Materials for a
project or group of projects.
+
The Java Platform can be used to define and/or constrain
projects to a known working set of dependencies.  Similar to
our base-pom files, our dependency versions can be declared
here and omitted from individual project dependency
declarations.
+
See {javaPlatDocs}[the Gradle docs] for more information.